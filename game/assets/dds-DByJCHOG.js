import{A as D,R as pt,b as Ft,I as Ct,_ as dt,c as T,C as U}from"./index-C8SlU0Sy.js";import{C as _t}from"./passPostProcess-DIhqjUy-.js";let W,Y;function H(A){W||(W=new Float32Array(1),Y=new Int32Array(W.buffer)),W[0]=A;const a=Y[0];let t=a>>16&32768,e=a>>12&2047;const o=a>>23&255;return o<103?t:o>142?(t|=31744,t|=(o==255?0:1)&&a&8388607,t):o<113?(e|=2048,t|=(e>>114-o)+(e>>113-o&1),t):(t|=o-112<<10|e>>1,t+=e&1,t)}function I(A){const a=(A&32768)>>15,t=(A&31744)>>10,e=A&1023;return t===0?(a?-1:1)*Math.pow(2,-14)*(e/Math.pow(2,10)):t==31?e?NaN:(a?-1:1)*(1/0):(a?-1:1)*Math.pow(2,t-15)*(1+e/Math.pow(2,10))}function Gt(A){const a=A.split("?")[0],t=a.lastIndexOf(".");return t>-1?a.substring(t).toLowerCase():""}D.prototype._partialLoadFile=function(A,a,t,e,o=null){const l=r=>{t[a]=r,t._internalCount++,t._internalCount===6&&e(t)},y=(r,i)=>{o&&r&&o(r.status+" "+r.statusText,i)};this._loadFile(A,l,void 0,void 0,!0,y)};D.prototype._cascadeLoadFiles=function(A,a,t,e=null){const o=[];o._internalCount=0;for(let l=0;l<6;l++)this._partialLoadFile(t[l],l,o,a,e)};D.prototype._cascadeLoadImgs=function(A,a,t,e,o=null,l){const y=[];y._internalCount=0;for(let r=0;r<6;r++)this._partialLoadImg(e[r],r,y,A,a,t,o,l)};D.prototype._partialLoadImg=function(A,a,t,e,o,l,y=null,r){const i=pt();Ft(A,c=>{t[a]=c,t._internalCount++,e&&e.removePendingData(i),t._internalCount===6&&l&&l(o,t)},(c,f)=>{e&&e.removePendingData(i),y&&y(c,f)},e?e.offlineProvider:null,r),e&&e.addPendingData(i)};D.prototype.createCubeTextureBase=function(A,a,t,e,o=null,l=null,y,r=null,i=!1,n=0,s=0,c=null,f=null,h=null,p=!1,F=null){const u=c||new Ct(this,7);u.isCube=!0,u.url=A,u.generateMipMaps=!e,u._lodGenerationScale=n,u._lodGenerationOffset=s,u._useSRGBBuffer=!!p&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),u!==c&&(u.label=A.substring(0,60)),this._doNotHandleContextLost||(u._extension=r,u._files=t,u._buffer=F);const _=A;this._transformTextureUrl&&!c&&(A=this._transformTextureUrl(A));const R=r??Gt(A),P=dt(R),m=(G,d)=>{u.dispose(),l?l(G,d):G&&T.Warn(G)},L=(G,d)=>{A===_?G&&m(G.status+" "+G.statusText,d):(T.Warn(`Failed to load ${A}, falling back to the ${_}`),this.createCubeTextureBase(_,a,t,!!e,o,m,y,r,i,n,s,u,f,h,p,F))};if(P)P.then(G=>{const d=b=>{f&&f(u,b),G.loadCubeData(b,u,i,o,(M,E)=>{m(M,E)})};F?d(F):t&&t.length===6?G.supportCascades?this._cascadeLoadFiles(a,b=>d(b.map(M=>new Uint8Array(M))),t,m):m("Textures type does not support cascades."):this._loadFile(A,b=>d(new Uint8Array(b)),void 0,void 0,!0,L)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(a,u,(G,d)=>{h&&h(G,d)},t,m)}return this._internalTexturesCache.push(u),u};const ht=542327876,Z=131072,v=512,S=4,q=64,tt=131072;function N(A){return A.charCodeAt(0)+(A.charCodeAt(1)<<8)+(A.charCodeAt(2)<<16)+(A.charCodeAt(3)<<24)}function xt(A){return String.fromCharCode(A&255,A>>8&255,A>>16&255,A>>24&255)}const et=N("DXT1"),rt=N("DXT3"),at=N("DXT5"),$=N("DX10"),nt=113,ot=116,st=2,ft=10,mt=88,j=31,bt=0,Bt=1,it=2,ct=3,J=4,lt=7,K=20,ut=21,Rt=22,Ot=23,wt=24,Ut=25,It=26,Lt=28,gt=32;class C{static GetDDSInfo(a){const t=new Int32Array(a.buffer,a.byteOffset,j),e=new Int32Array(a.buffer,a.byteOffset,j+4);let o=1;t[it]&Z&&(o=Math.max(1,t[lt]));const l=t[ut],y=l===$?e[gt]:0;let r=0;switch(l){case nt:r=2;break;case ot:r=1;break;case $:if(y===ft){r=2;break}if(y===st){r=1;break}}return{width:t[J],height:t[ct],mipmapCount:o,isFourCC:(t[K]&S)===S,isRGB:(t[K]&q)===q,isLuminance:(t[K]&tt)===tt,isCube:(t[Lt]&v)===v,isCompressed:l===et||l===rt||l===at,dxgiFormat:y,textureType:r}}static _GetHalfFloatAsFloatRGBAArrayBuffer(a,t,e,o,l,y){const r=new Float32Array(o),i=new Uint16Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++){const f=(c+s*a)*4;r[n]=I(i[f]),r[n+1]=I(i[f+1]),r[n+2]=I(i[f+2]),C.StoreLODInAlphaChannel?r[n+3]=y:r[n+3]=I(i[f+3]),n+=4}return r}static _GetHalfFloatRGBAArrayBuffer(a,t,e,o,l,y){if(C.StoreLODInAlphaChannel){const r=new Uint16Array(o),i=new Uint16Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++){const f=(c+s*a)*4;r[n]=i[f],r[n+1]=i[f+1],r[n+2]=i[f+2],r[n+3]=H(y),n+=4}return r}return new Uint16Array(l,e,o)}static _GetFloatRGBAArrayBuffer(a,t,e,o,l,y){if(C.StoreLODInAlphaChannel){const r=new Float32Array(o),i=new Float32Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++){const f=(c+s*a)*4;r[n]=i[f],r[n+1]=i[f+1],r[n+2]=i[f+2],r[n+3]=y,n+=4}return r}return new Float32Array(l,e,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(a,t,e,o,l,y){const r=new Uint16Array(o),i=new Float32Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++)r[n]=H(i[n]),r[n+1]=H(i[n+1]),r[n+2]=H(i[n+2]),C.StoreLODInAlphaChannel?r[n+3]=H(y):r[n+3]=H(i[n+3]),n+=4;return r}static _GetFloatAsUIntRGBAArrayBuffer(a,t,e,o,l,y){const r=new Uint8Array(o),i=new Float32Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++){const f=(c+s*a)*4;r[n]=U(i[f])*255,r[n+1]=U(i[f+1])*255,r[n+2]=U(i[f+2])*255,C.StoreLODInAlphaChannel?r[n+3]=y:r[n+3]=U(i[f+3])*255,n+=4}return r}static _GetHalfFloatAsUIntRGBAArrayBuffer(a,t,e,o,l,y){const r=new Uint8Array(o),i=new Uint16Array(l,e);let n=0;for(let s=0;s<t;s++)for(let c=0;c<a;c++){const f=(c+s*a)*4;r[n]=U(I(i[f]))*255,r[n+1]=U(I(i[f+1]))*255,r[n+2]=U(I(i[f+2]))*255,C.StoreLODInAlphaChannel?r[n+3]=y:r[n+3]=U(I(i[f+3]))*255,n+=4}return r}static _GetRGBAArrayBuffer(a,t,e,o,l,y,r,i,n){const s=new Uint8Array(o),c=new Uint8Array(l,e);let f=0;for(let h=0;h<t;h++)for(let p=0;p<a;p++){const F=(p+h*a)*4;s[f]=c[F+y],s[f+1]=c[F+r],s[f+2]=c[F+i],s[f+3]=c[F+n],f+=4}return s}static _ExtractLongWordOrder(a){return a===0||a===255||a===-16777216?0:1+C._ExtractLongWordOrder(a>>8)}static _GetRGBArrayBuffer(a,t,e,o,l,y,r,i){const n=new Uint8Array(o),s=new Uint8Array(l,e);let c=0;for(let f=0;f<t;f++)for(let h=0;h<a;h++){const p=(h+f*a)*3;n[c]=s[p+y],n[c+1]=s[p+r],n[c+2]=s[p+i],c+=3}return n}static _GetLuminanceArrayBuffer(a,t,e,o,l){const y=new Uint8Array(o),r=new Uint8Array(l,e);let i=0;for(let n=0;n<t;n++)for(let s=0;s<a;s++){const c=s+n*a;y[i]=r[c],i++}return y}static UploadDDSLevels(a,t,e,o,l,y,r=-1,i,n=!0){let s=null;o.sphericalPolynomial&&(s=[]);const c=!!a.getCaps().s3tc;t.generateMipMaps=l;const f=new Int32Array(e.buffer,e.byteOffset,j);let h,p,F,u=0,_,R,P,m,L=0,G=1;if(f[bt]!==ht){T.Error("Invalid magic number in DDS header");return}if(!o.isFourCC&&!o.isRGB&&!o.isLuminance){T.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(o.isCompressed&&!c){T.Error("Compressed textures are not supported on this platform.");return}let d=f[Rt];_=f[Bt]+4;let b=!1;if(o.isFourCC)switch(h=f[ut],h){case et:G=8,L=33777;break;case rt:G=16,L=33778;break;case at:G=16,L=33779;break;case nt:b=!0,d=64;break;case ot:b=!0,d=128;break;case $:{_+=5*4;let B=!1;switch(o.dxgiFormat){case ft:b=!0,d=64,B=!0;break;case st:b=!0,d=128,B=!0;break;case mt:o.isRGB=!0,o.isFourCC=!1,d=32,B=!0;break}if(B)break}default:T.Error(["Unsupported FourCC code:",xt(h)]);return}const M=C._ExtractLongWordOrder(f[Ot]),E=C._ExtractLongWordOrder(f[wt]),Q=C._ExtractLongWordOrder(f[Ut]),At=C._ExtractLongWordOrder(f[It]);b&&(L=a._getRGBABufferInternalSizedFormat(o.textureType)),P=1,f[it]&Z&&l!==!1&&(P=Math.max(1,f[lt]));const yt=i||0,k=a.getCaps();for(let B=yt;B<y;B++){for(p=f[J],F=f[ct],m=0;m<P;++m){if(r===-1||r===m){const x=r===-1?m:0;if(!o.isCompressed&&o.isFourCC){t.format=5,u=p*F*4;let O=null;if(a._badOS||a._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)d===128?(O=C._GetFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(C._GetFloatRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x))):d===64&&(O=C._GetHalfFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(C._GetHalfFloatAsFloatRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,x))),t.type=0;else{const X=k.textureFloat&&(n&&k.textureFloatLinearFiltering||!n),z=k.textureHalfFloat&&(n&&k.textureHalfFloatLinearFiltering||!n),V=(d===128||d===64&&!z)&&X?1:(d===64||d===128&&!X)&&z?2:0;let g,w=null;switch(d){case 128:{switch(V){case 1:g=C._GetFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetFloatAsHalfFloatRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break;case 0:g=C._GetFloatAsUIntRGBAArrayBuffer,w=C._GetFloatRGBAArrayBuffer;break}break}default:{switch(V){case 1:g=C._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:g=C._GetHalfFloatRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:g=C._GetHalfFloatAsUIntRGBAArrayBuffer,w=C._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=V,O=g(p,F,e.byteOffset+_,u,e.buffer,x),s&&x==0&&s.push(w?w(p,F,e.byteOffset+_,u,e.buffer,x):O)}O&&a._uploadDataToTextureDirectly(t,O,B,x)}else if(o.isRGB)t.type=0,d===24?(t.format=4,u=p*F*3,R=C._GetRGBArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,M,E,Q),a._uploadDataToTextureDirectly(t,R,B,x)):(t.format=5,u=p*F*4,R=C._GetRGBAArrayBuffer(p,F,e.byteOffset+_,u,e.buffer,M,E,Q,At),a._uploadDataToTextureDirectly(t,R,B,x));else if(o.isLuminance){const O=a._getUnpackAlignement(),X=p;u=Math.floor((p+O-1)/O)*O*(F-1)+X,R=C._GetLuminanceArrayBuffer(p,F,e.byteOffset+_,u,e.buffer),t.format=1,t.type=0,a._uploadDataToTextureDirectly(t,R,B,x)}else u=Math.max(4,p)/4*Math.max(4,F)/4*G,R=new Uint8Array(e.buffer,e.byteOffset+_,u),t.type=0,a._uploadCompressedDataToTextureDirectly(t,L,p,F,R,B,x)}_+=d?p*F*(d/8):u,p*=.5,F*=.5,p=Math.max(1,p),F=Math.max(1,F)}if(i!==void 0)break}s&&s.length>0?o.sphericalPolynomial=_t.ConvertCubeMapToSphericalPolynomial({size:f[J],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}C.StoreLODInAlphaChannel=!1;export{C as DDSTools};
